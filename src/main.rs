use crate::{
	hardware::hardware::Hardware,
	system::System
};

mod system;
mod hardware;
mod ascii;

#[tokio::main]
async fn main() {
	let start_address: u16 = 0x0000;
	//Bubble-sort program, 245 bytes long
	//I managed to get it all on the zeroth-page, but it still doesn't work in tsiram.com because it surpasses the clock cycle limit
	let sort_program: &[u8] = &[
		/*See bubbleSort.asm6502 to look at the assembly code I wrote to produce this array of bytes.
		See README.md to check out the text-editor/assembler I made to assembly bubbleSort.asm6502*/
		0xA2, 0x03, 0xFF, 0xD6, 0x00, 0xAD, 0xEB, 0x00, 0xA2, 0x01, 0xAC, 0xEC, 0x00, 0xFF, 0xA2, 0x03, 0xFF, 0xE8, 0x00, 0xEE, 0x0B, 0x00, 0x6D, 0xD5, 0x00, 0xD0, 0xED, 0xAD, 0xEB, 0x00, 0x6D, 0xD5, 0x00, 0x8D, 0xD2, 0x00, 0xAE, 0xD2, 0x00, 0xEC, 0xCF, 0x00, 0xD0, 0x1C, 0xA2, 0x03, 0xFF, 0xDD, 0x00, 0xAD, 0xEB, 0x00, 0xA2, 0x01, 0xAC, 0xEC, 0x00, 0xFF, 0xA2, 0x03, 0xFF, 0xE8, 0x00, 0xEE, 0x37, 0x00, 0x6D, 0xD5, 0x00, 0xD0, 0xED, 0x00, 0xA9, 0x00, 0x8D, 0xD3, 0x00, 0x8D, 0xD1, 0x00, 0xAD, 0xD2, 0x00, 0x6D, 0xD0, 0x00, 0xAA, 0xEC, 0xD1, 0x00, 0xD0, 0x0C, 0xAD, 0xD3, 0x00, 0x6D, 0x47, 0x00, 0xD0, 0x5D, 0xA2, 0x03, 0xD0, 0xC6, 0xAD, 0x37, 0x00, 0x6D, 0xD1, 0x00, 0x8D, 0x78, 0x00, 0x8D, 0x9C, 0x00, 0x8D, 0xA6, 0x00, 0xAE, 0xEC, 0x00, 0x6D, 0xD4, 0x00, 0x8D, 0x8A, 0x00, 0x8D, 0x96, 0x00, 0x8D, 0x9F, 0x00, 0x8D, 0xA2, 0x00, 0xEC, 0xEC, 0x00, 0xD0, 0x07, 0xA8, 0xA2, 0x01, 0xD0, 0x1A, 0xD0, 0x8F, 0xAC, 0xEC, 0x00, 0x98, 0xD0, 0x17, 0xAD, 0xEC, 0x00, 0xAC, 0xEC, 0x00, 0x8D, 0xEC, 0x00, 0x98, 0x8D, 0xEC, 0x00, 0xA9, 0x01, 0x8D, 0xD3, 0x00, 0xEE, 0xD1, 0x00, 0xD0, 0x9E, 0x6D, 0xD5, 0x00, 0xA8, 0x8A, 0x6D, 0xD5, 0x00, 0xAA, 0xD0, 0xDB, 0xA2, 0x01, 0xD0, 0xEC, 0xAD, 0xD0, 0x00, 0x6D, 0xD5, 0x00, 0x8D, 0xD0, 0x00, 0xEE, 0xCF, 0x00, 0xD0, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x49, 0x6E, 0x69, 0x74, 0x20, 0x20, 0x00, 0x20, 0x20, 0x53, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x20, 0x00, 0x2C, 0x20, 0x00, 0x0A, 0x08, 0x03, 0x01, 0x09, 0x07, 0x05, 0x02, 0x0A, 0x04, 0x06
	];
	
	let _ = lib::elapsed_ms();//initializes the timer to get the elapsed time
	let mut system: System = System::new();
	
	system.clock.get_specs_mut().debug = false;
	system.clock.cpu.get_specs_mut().debug = false;
	system.clock.memory.get_specs_mut().debug = false;
	
	system.load_main_program(start_address, sort_program);
	system.start().await;
}

mod lib {
	use std::time::Instant;
	
	static mut START_TIME: Option<Instant> = None;
	
	/**Gets the elapsed ms since the program started.*/
	pub fn elapsed_ms() -> u128 {
		unsafe {
			if START_TIME.is_none() {START_TIME = Some(Instant::now());}
			return Instant::now().duration_since(START_TIME.unwrap()).as_millis();
		}
	}
	/**Converts a u16 to a (u8,u8) tuple in little-endian format.*/
	pub fn u16_to_little_endian(value: u16) -> (u8, u8) {
		let byte1: u8 = (value & 0xFF) as u8;
		let byte2: u8 = ((value >> 8) & 0xFFu16) as u8;
		return (byte1, byte2);
	}
}